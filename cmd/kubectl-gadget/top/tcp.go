// Copyright 2019-2021 The Inspektor Gadget authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package top

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"golang.org/x/term"

	"github.com/kinvolk/inspektor-gadget/cmd/kubectl-gadget/utils"
	"github.com/kinvolk/inspektor-gadget/pkg/gadgets/tcptop/types"
)

var (
	nodeTCPStats map[string][]types.Stats
	mtx          sync.Mutex
)

var (
	// arguments
	intervalOutput int = types.IntervalDefault

	// flags
	maximumRows int
	sortTypeStr string
	sortType    types.SortBy
	filteredPid uint
	family      uint
)

var tcptopCmd = &cobra.Command{
	Use:   fmt.Sprintf("tcp [interval=%d]", types.IntervalDefault),
	Short: "Trace TCP connection",
	RunE: func(cmd *cobra.Command, args []string) error {
		var err error

		nodeTCPStats = make(map[string][]types.Stats)

		if len(args) == 1 {
			intervalOutput, err = strconv.Atoi(args[0])
			if err != nil {
				return utils.WrapInErrInvalidArg("interval", fmt.Errorf("%q is not a valid value", args[0]))
			}
		}

		parameters := map[string]string{
			types.MaxRowsParam:  strconv.Itoa(maximumRows),
			types.IntervalParam: strconv.Itoa(intervalOutput),
			types.SortByParam:   sortTypeStr,
		}

		if family != 0 {
			parameters[types.FamilyParam] = strconv.FormatUint(uint64(family), 10)
		}

		if filteredPid != 0 {
			parameters[types.PidParam] = strconv.FormatUint(uint64(filteredPid), 10)
		}

		config := &utils.TraceConfig{
			GadgetName:       "tcptop",
			Operation:        "start",
			TraceOutputMode:  "Stream",
			TraceOutputState: "Started",
			CommonFlags:      &params,
			Parameters:       parameters,
		}

		startoutput()

		if err := utils.RunTraceStreamCallback(config, hook); err != nil {
			return fmt.Errorf("error running trace: %w", err)
		}

		return nil
	},
	SilenceUsage: true,
	PreRunE: func(cmd *cobra.Command, args []string) error {
		var err error
		sortType, err = types.ParseSortBy(sortTypeStr)
		if err != nil {
			return err
		}

		return nil
	},
	Args: cobra.MaximumNArgs(1),
}

func init() {
	tcptopCmd.Flags().IntVarP(&maximumRows, "maximumRows", "r", types.MaxRowsDefault, "Maximum rows to print")
	tcptopCmd.Flags().StringVarP(&sortTypeStr, "sort", "", types.SortByAll, fmt.Sprintf("Sort column, possible values are: %s", strings.Join(types.SortBySlice, ", ")))
	tcptopCmd.PersistentFlags().UintVarP(
		&filteredPid,
		"pid",
		"",
		0,
		"Show only TCP events generated by this particular PID",
	)
	tcptopCmd.PersistentFlags().UintVarP(
		&family,
		"family",
		"f",
		0,
		"Show only TCP events for this IP version: either 4 or 6 (by default all will be printed)",
	)

	TopCmd.AddCommand(tcptopCmd)
	utils.AddCommonFlags(tcptopCmd, &params)
}

func hook(line string, node string) {
	mtx.Lock()
	defer mtx.Unlock()

	var event types.Event

	if err := json.Unmarshal([]byte(line), &event); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %s", utils.WrapInErrUnmarshalOutput(err))
		return
	}

	if event.Error != "" {
		fmt.Fprintf(os.Stderr, "Error: failed on node %q: %s", event.Node, event.Error)
		return
	}

	nodeTCPStats[node] = event.Stats
}

func startoutput() {
	ticker := time.NewTicker(time.Duration(intervalOutput) * time.Second)

	go func() {
		for {
			output()
			<-ticker.C
		}
	}()
}

func output() {
	// sort and print events
	mtx.Lock()

	stats := []types.Stats{}
	for _, stat := range nodeTCPStats {
		stats = append(stats, stat...)
	}
	nodeTCPStats = make(map[string][]types.Stats)

	mtx.Unlock()

	types.SortStats(stats, sortType)

	switch params.OutputMode {
	case utils.OutputModeColumns:
		if term.IsTerminal(int(os.Stdout.Fd())) {
			utils.ClearScreen()
		} else {
			fmt.Println("")
		}

		fmt.Printf("%-16s %-16s %-16s %-16s %-7s %-16s %-3s %-51s %-51s %-7s %s\n",
			"NODE", "NAMESPACE", "POD", "CONTAINER",
			"PID", "COMM", "IPv", "LADDR", "RADDR", "RX_KB", "TX_KB")
		for idx, event := range stats {
			if idx == maximumRows {
				break
			}

			family := 4
			if event.Family == syscall.AF_INET6 {
				family = 6
			}

			fmt.Printf("%-16s %-16s %-16s %-16s %-7d %-16s %-3d %-51s %-51s %-7d %d\n",
				event.Node, event.Namespace, event.Pod, event.Container,
				event.Pid, event.Comm, family,
				fmt.Sprintf("%s:%d", event.Saddr, event.Sport),
				fmt.Sprintf("%s:%d", event.Daddr, event.Dport),
				event.Received/1048, event.Sent/1048)
		}
	case utils.OutputModeJSON:
		b, err := json.Marshal(stats)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error marshalling json: %v", err)
			return
		}
		fmt.Println(string(b))
	case utils.OutputModeCustomColumns:
		if term.IsTerminal(int(os.Stdout.Fd())) {
			utils.ClearScreen()
		} else {
			fmt.Println("")
		}
		fmt.Println(getCustomTcptopColsHeader(params.CustomColumns))
		for idx, stat := range stats {
			if idx == maximumRows {
				break
			}
			fmt.Println(formatEventTcptopCustomCols(&stat, params.CustomColumns))
		}
	}
}

func getCustomTcptopColsHeader(cols []string) string {
	var sb strings.Builder

	for _, col := range cols {
		switch col {
		case "node":
			sb.WriteString(fmt.Sprintf("%-16s", "NODE"))
		case "namespace":
			sb.WriteString(fmt.Sprintf("%-16s", "NAMESPACE"))
		case "pod":
			sb.WriteString(fmt.Sprintf("%-16s", "POD"))
		case "container":
			sb.WriteString(fmt.Sprintf("%-16s", "CONTAINER"))
		case "pid":
			sb.WriteString(fmt.Sprintf("%-7s", "PID"))
		case "comm":
			sb.WriteString(fmt.Sprintf("%-16s", "COMM"))
		case "family":
			sb.WriteString(fmt.Sprintf("%-3s", "IPv"))
		case "saddr":
			sb.WriteString(fmt.Sprintf("%-51s", "LADDR"))
		case "daddr":
			sb.WriteString(fmt.Sprintf("%-51s", "DADDR"))
		case "sent":
			sb.WriteString(fmt.Sprintf("%-7s", "TX_KB"))
		case "received":
			sb.WriteString(fmt.Sprintf("%-7s", "RX_KB"))
		}
		sb.WriteRune(' ')
	}

	return sb.String()
}

func formatEventTcptopCustomCols(stats *types.Stats, cols []string) string {
	var sb strings.Builder

	for _, col := range cols {
		switch col {
		case "node":
			sb.WriteString(fmt.Sprintf("%-16s", stats.Node))
		case "namespace":
			sb.WriteString(fmt.Sprintf("%-16s", stats.Namespace))
		case "pod":
			sb.WriteString(fmt.Sprintf("%-16s", stats.Pod))
		case "container":
			sb.WriteString(fmt.Sprintf("%-16s", stats.Container))
		case "pid":
			sb.WriteString(fmt.Sprintf("%-7d", stats.Pid))
		case "comm":
			sb.WriteString(fmt.Sprintf("%-16s", stats.Comm))
		case "family":
			family := 4
			if stats.Family == syscall.AF_INET6 {
				family = 6
			}

			sb.WriteString(fmt.Sprintf("%-3d", family))
		case "saddr":
			sb.WriteString(fmt.Sprintf("%-51s", fmt.Sprintf("%s:%d", stats.Saddr, stats.Sport)))
		case "daddr":
			sb.WriteString(fmt.Sprintf("%-51s", fmt.Sprintf("%s:%d", stats.Daddr, stats.Dport)))
		case "sent":
			sb.WriteString(fmt.Sprintf("%-7d", stats.Sent))
		case "received":
			sb.WriteString(fmt.Sprintf("%d", stats.Received))
		}
		sb.WriteRune(' ')
	}

	return sb.String()
}
